#include <stdio.h>
#include "CH58x_common.h"
#include "ringbuffer.h"
#include "at.h"

#define LED  GPIO_Pin_19
RingBuffer txBuffer, rxBuffer;

static volatile uint32_t jiffies = 0;

#define TASK_LEN (4)

typedef void (*TaskFunction)(void);

typedef struct {
  TaskFunction task;
  uint32_t period;
  uint32_t delay;
  BOOL ready;
} Task;

static Task taskList[TASK_LEN];

void registerTask(uint8_t index, TaskFunction task, unsigned int period, unsigned int delay) {
  taskList[index].task = task;
  taskList[index].period = period;
  taskList[index].delay = delay;
}

int _write(int fd, char *buf, int size) {
  for (int i = 0; i < size; i++) {
    ringbufferPut(&txBuffer, *buf++, TRUE);
    if (R8_UART1_LSR & RB_LSR_TX_FIFO_EMP) {
      while (ringbufferAvailable(&txBuffer) && R8_UART1_TFC < UART_FIFO_SIZE) {
        R8_UART1_THR = ringbufferGet(&txBuffer);
      }
    }
  }
  return size;
}

void delayInJiffy(uint32_t t) {
  uint32_t start = jiffies;
  while (t) {
    if (jiffies != start) {
      t--;
      start++;
    } else {
      __WFI();
      __nop();
      __nop();
    }
  }
}

void flushUart1Tx() {
  while (!(R8_UART1_LSR & RB_LSR_TX_FIFO_EMP)) {
    __WFI();
  }
}

void handleAT(uint8_t * payload, uint8_t len) {
  sendOK();
}

void handleATMAC(uint8_t * payload, uint8_t len) {
  uint8_t mac[6];
  GetMACAddress(mac);
  for (uint8_t i = 6; i--;) {
    printf("%02X", mac[i]);
  }
  sendOK();
}

void handleATID(uint8_t * payload, uint8_t len) {
  uint8_t id[8];
  FLASH_EEPROM_CMD(CMD_GET_UNIQUE_ID, 0, id, 0);
  for (uint8_t i = 0; i < 8; i++) {
    printf("%02X", id[i]);
  }
  sendOK();
}

void handleATRESET(uint8_t * payload, uint8_t len) {
  sendOK();
  flushUart1Tx();
  SYS_ResetExecute();
}

void handleATECHO(uint8_t * payload, uint8_t len) {
  for (uint8_t i = 0; i < len; i++) {
    printf("%02X", payload[i]);
  }
  sendOK();
}

void handleATSC(uint8_t * payload, uint8_t len) {
  for (uint8_t slaveAddress = 0x03; slaveAddress < 0x78; slaveAddress++) {
    while (I2C_GetFlagStatus(I2C_FLAG_BUSY) != RESET);

    I2C_GenerateSTART(ENABLE);
    while(!I2C_CheckEvent(I2C_EVENT_MASTER_MODE_SELECT));

    I2C_Send7bitAddress(slaveAddress << 1, I2C_Direction_Transmitter);
    while (!I2C_CheckEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) && !I2C_GetFlagStatus(I2C_FLAG_AF));

    if (I2C_GetFlagStatus(I2C_FLAG_AF)) {
      I2C_ClearFlag(I2C_FLAG_AF);
    }

    BOOL acked = I2C_GetFlagStatus(I2C_FLAG_TXE);
    I2C_GenerateSTOP(ENABLE);

    if (acked) {
      printf("%02X", slaveAddress);
    }
  }

  sendOK();
}

void handleATTR(uint8_t * payload, uint8_t len) {
  if (len < 2) {
    return sendError();
  }

  I2C_GenerateSTART(ENABLE);
  while (!I2C_CheckEvent(I2C_EVENT_MASTER_MODE_SELECT)); // 0x00030001

  I2C_Send7bitAddress(payload[0] << 1, I2C_Direction_Transmitter);
  while (!I2C_CheckEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) && !I2C_GetFlagStatus(I2C_FLAG_AF));  // 0x00070082

  if (I2C_GetFlagStatus(I2C_FLAG_AF)) {
    I2C_ClearFlag(I2C_FLAG_AF);
    I2C_GenerateSTOP(ENABLE);
    return sendError();
  }

  if (len > 2) {
    uint8_t writeCount = len - 2;
    uint8_t *toWrite = payload + 1;
    while (writeCount--) {
      I2C_SendData(*toWrite++);
      while (!I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED));  // 0x00070084
    }
  }

  uint8_t readCount = payload[len - 1];

  if (readCount) {
    I2C_GenerateSTART(ENABLE);  // restart
    while (!I2C_CheckEvent(I2C_EVENT_MASTER_MODE_SELECT)); // 0x00030001

    I2C_Send7bitAddress(payload[0] << 1, I2C_Direction_Receiver);
    while (!I2C_CheckEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)); // 0x00030002

    while (readCount--) {
      I2C_AcknowledgeConfig(readCount);
      while (!I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_RECEIVED)); // 0x00030040
      printf("%02X", I2C_ReceiveData());
    }
  }

  I2C_GenerateSTOP(ENABLE);
  while (I2C_GetFlagStatus(I2C_FLAG_BUSY) != RESET); // 0x00000000

  sendOK();
}

static const uint8_t FONTS[] = {  // 16x7
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x19,0x00,0x00,0x00,0x00,0x01,0x00,0x09,0x00,0x07,0x00,0x00,0x00,0x01,0x00,0x09,0x00,0x07,0x00,0x00,0x02,0x20,0x1e,0xe0,0x03,0x3c,0x02,0x20,0x1e,0xe0,0x03,0x3c,0x02,0x1c,0x04,0x22,0x08,0x42,0x08,0xff,0x1f,0x42,0x08,0x82,0x08,0x04,0x07,0x06,0x18,0x09,0x06,0x89,0x01,0x46,0x0c,0x30,0x12,0x0c,0x12,0x03,0x0c,0x80,0x0f,0xde,0x18,0x61,0x10,0xa1,0x11,0x11,0x16,0x0e,0x08,0x80,0x17,0x00,0x00,0x00,0x00,0x09,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x03,0x06,0x0c,0x01,0x10,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x10,0x06,0x0c,0xf8,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x00,0x60,0x00,0xf8,0x01,0x60,0x00,0x90,0x00,0x00,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0xf8,0x03,0x40,0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x00,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1c,0x00,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1c,0x80,0x03,0x60,0x00,0x1c,0x00,0x03,0x00,0x00,0x00,0xfc,0x07,0x02,0x08,0x81,0x10,0x41,0x10,0x21,0x10,0x02,0x08,0xfc,0x07,0x00,0x00,0x04,0x00,0x02,0x00,0x01,0x00,0xff,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x1c,0x01,0x13,0x81,0x10,0x41,0x10,0x21,0x10,0x1e,0x10,0x00,0x00,0x02,0x08,0x01,0x10,0x21,0x10,0x21,0x10,0x21,0x10,0xde,0x0f,0x80,0x01,0x40,0x01,0x30,0x01,0x08,0x01,0x06,0x01,0xff,0x1f,0x00,0x01,0x00,0x00,0x3f,0x08,0x21,0x10,0x21,0x10,0x21,0x10,0x21,0x10,0xc1,0x0f,0x00,0x00,0xfe,0x0f,0x21,0x10,0x21,0x10,0x21,0x10,0x21,0x10,0xc2,0x0f,0x01,0x00,0x01,0x00,0x01,0x1e,0xc1,0x01,0x21,0x00,0x19,0x00,0x07,0x00,0x00,0x00,0xde,0x0f,0x21,0x10,0x21,0x10,0x21,0x10,0x21,0x10,0xde,0x0f,0x00,0x00,0x3e,0x08,0x41,0x10,0x41,0x10,0x41,0x10,0x41,0x10,0xfe,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x06,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x0a,0x18,0x06,0x00,0x00,0x00,0x00,0x40,0x00,0xa0,0x00,0xa0,0x00,0x10,0x01,0x08,0x02,0x08,0x02,0x04,0x04,0x10,0x01,0x10,0x01,0x10,0x01,0x10,0x01,0x10,0x01,0x10,0x01,0x10,0x01,0x04,0x04,0x08,0x02,0x08,0x02,0x10,0x01,0xa0,0x00,0xa0,0x00,0x40,0x00,0x00,0x00,0x02,0x00,0x01,0x00,0x81,0x19,0x41,0x00,0x21,0x00,0x1e,0x00,0xfc,0x07,0x02,0x08,0xe1,0x11,0x11,0x12,0x11,0x12,0x12,0x12,0xfc,0x09,0xc0,0x1f,0xb8,0x00,0x86,0x00,0x81,0x00,0x86,0x00,0xb8,0x00,0xc0,0x1f,0xff,0x1f,0x21,0x10,0x21,0x10,0x21,0x10,0x21,0x10,0x21,0x10,0xde,0x0f,0xfc,0x07,0x02,0x08,0x01,0x10,0x01,0x10,0x01,0x10,0x01,0x10,0x02,0x08,0xff,0x1f,0x01,0x10,0x01,0x10,0x01,0x10,0x01,0x10,0x02,0x08,0xfc,0x07,0xff,0x1f,0x21,0x10,0x21,0x10,0x21,0x10,0x21,0x10,0x01,0x10,0x00,0x00,0xff,0x1f,0x21,0x00,0x21,0x00,0x21,0x00,0x21,0x00,0x01,0x00,0x00,0x00,0xfe,0x0f,0x01,0x10,0x01,0x10,0x01,0x10,0x81,0x10,0x81,0x10,0x82,0x0f,0xff,0x1f,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0xff,0x1f,0x00,0x00,0x01,0x10,0x01,0x10,0xff,0x1f,0x01,0x10,0x01,0x10,0x00,0x00,0x01,0x0c,0x01,0x10,0x01,0x10,0x01,0x10,0x01,0x10,0x01,0x10,0xff,0x0f,0xff,0x1f,0x40,0x00,0x60,0x00,0x98,0x00,0x04,0x03,0x03,0x0c,0x00,0x10,0xff,0x1f,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0xff,0x1f,0x02,0x00,0x0c,0x00,0x10,0x00,0x0c,0x00,0x02,0x00,0xff,0x1f,0xff,0x1f,0x02,0x00,0x0c,0x00,0x10,0x00,0x60,0x00,0x80,0x00,0xff,0x1f,0xfc,0x07,0x02,0x08,0x01,0x10,0x01,0x10,0x01,0x10,0x02,0x08,0xfc,0x07,0xff,0x1f,0x41,0x00,0x41,0x00,0x41,0x00,0x41,0x00,0x22,0x00,0x1c,0x00,0xfc,0x07,0x02,0x08,0x01,0x10,0x01,0x10,0x01,0x14,0x02,0x08,0xfc,0x17,0xff,0x1f,0x41,0x00,0x41,0x00,0x41,0x00,0xc1,0x00,0x41,0x03,0x3e,0x1c,0x1c,0x04,0x22,0x08,0x41,0x10,0x41,0x10,0x41,0x10,0x82,0x08,0x04,0x07,0x01,0x00,0x01,0x00,0x01,0x00,0xff,0x1f,0x01,0x00,0x01,0x00,0x01,0x00,0xff,0x07,0x00,0x08,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x08,0xff,0x07,0x0f,0x00,0xf0,0x00,0x00,0x07,0x00,0x18,0x00,0x07,0xf0,0x00,0x0f,0x00,0xff,0x07,0x00,0x18,0x00,0x07,0xc0,0x00,0x00,0x07,0x00,0x18,0xff,0x07,0x03,0x18,0x0c,0x06,0xb0,0x01,0x40,0x00,0xb0,0x01,0x0c,0x06,0x03,0x18,0x07,0x00,0x18,0x00,0x60,0x00,0x80,0x1f,0x60,0x00,0x18,0x00,0x07,0x00,0x01,0x1c,0x01,0x13,0x81,0x10,0x61,0x10,0x19,0x10,0x05,0x10,0x03,0x10,0x00,0x00,0x00,0x00,0xff,0x1f,0x01,0x10,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x38,0x00,0xc0,0x00,0x00,0x07,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x01,0x10,0xff,0x1f,0x00,0x00,0x00,0x00,0x08,0x00,0x04,0x00,0x02,0x00,0x01,0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x01,0x00,0x02,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x0f,0x88,0x10,0x88,0x10,0x88,0x10,0x88,0x08,0xf0,0x1f,0x00,0x00,0xff,0x1f,0x10,0x08,0x08,0x10,0x08,0x10,0x08,0x10,0xf0,0x0f,0x00,0x00,0xe0,0x07,0x10,0x08,0x08,0x10,0x08,0x10,0x08,0x10,0x10,0x08,0x00,0x00,0xf0,0x0f,0x08,0x10,0x08,0x10,0x08,0x10,0x10,0x08,0xff,0x1f,0x00,0x00,0xf0,0x0f,0x88,0x10,0x88,0x10,0x88,0x10,0x88,0x10,0xf0,0x08,0x10,0x00,0x10,0x00,0xfe,0x1f,0x11,0x00,0x11,0x00,0x11,0x00,0x02,0x00,0xf0,0x76,0x08,0x89,0x08,0x89,0x08,0x89,0x08,0x89,0xf8,0x88,0x08,0x70,0x00,0x00,0xff,0x1f,0x10,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0xf0,0x1f,0x00,0x00,0x00,0x00,0x08,0x10,0x08,0x10,0xf9,0x1f,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x20,0x00,0x40,0x08,0x40,0x08,0x40,0xf9,0x3f,0x00,0x00,0x00,0x00,0xff,0x1f,0x80,0x01,0x40,0x01,0x20,0x02,0x10,0x04,0x08,0x18,0x00,0x00,0x00,0x00,0x01,0x10,0x01,0x10,0xff,0x1f,0x00,0x10,0x00,0x10,0xf8,0x1f,0x08,0x00,0x08,0x00,0xf0,0x1f,0x08,0x00,0x08,0x00,0xf0,0x1f,0x00,0x00,0xf8,0x1f,0x10,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0xf0,0x1f,0xe0,0x07,0x10,0x08,0x08,0x10,0x08,0x10,0x08,0x10,0x10,0x08,0xe0,0x07,0x00,0x00,0xf8,0xff,0x10,0x08,0x08,0x10,0x08,0x10,0x08,0x10,0xf0,0x0f,0x00,0x00,0xf0,0x0f,0x08,0x10,0x08,0x10,0x08,0x10,0x10,0x08,0xf8,0xff,0x00,0x00,0xf8,0x1f,0x10,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x10,0x00,0x00,0x08,0x70,0x10,0x88,0x10,0x88,0x10,0x08,0x11,0x08,0x11,0x10,0x0e,0x08,0x00,0x08,0x00,0xff,0x0f,0x08,0x10,0x08,0x10,0x08,0x10,0x00,0x08,0x00,0x00,0xf8,0x0f,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x08,0xf8,0x1f,0x38,0x00,0xc0,0x01,0x00,0x0e,0x00,0x10,0x00,0x0e,0xc0,0x01,0x38,0x00,0xf8,0x07,0x00,0x18,0x00,0x06,0x80,0x01,0x00,0x06,0x00,0x18,0xf8,0x07,0x18,0x18,0x20,0x04,0x40,0x02,0x80,0x01,0x40,0x02,0x20,0x04,0x18,0x18,0x18,0x00,0xe0,0xc0,0x00,0x33,0x00,0x0c,0x00,0x03,0xe0,0x00,0x18,0x00,0x08,0x18,0x08,0x14,0x08,0x12,0x88,0x11,0x48,0x10,0x28,0x10,0x18,0x10,0x00,0x00,0x00,0x00,0x4e,0x0e,0xb1,0x11,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0xb1,0x11,0x4e,0x0e,0x00,0x00,0x80,0x00,0x40,0x00,0x40,0x00,0x80,0x00,0x00,0x01,0x00,0x01,0x80,0x00
};

static uint8_t screen[1024];

void putFont(char c, uint8_t row, uint8_t col) {
  const uint8_t * p = FONTS + (c - ' ') * 14;
  uint16_t i = col * 8 + row;
  if (row > 6) return;
  if (col > 120) return;
  for (int8_t j = 0; j < 14;) {
    screen[i] = p[j++];
    screen[i + 1] = p[j++];
    i += 8;
  }
}

void putString(const char * s, uint8_t row, uint8_t col) {
  uint8_t i = 0;
  while (s[i]) {
    putFont(s[i++], row, col);
    col += 8;
    if (col == 128) {
      col = 0;
      row += 2;
    }
  }
}

void ssdInit() {
  // GPIOA_SetBits(GPIO_Pin_12);
  // GPIOA_ModeCfg(GPIO_Pin_12, GPIO_ModeOut_PP_5mA); // CSN
  GPIOA_ModeCfg(GPIO_Pin_13, GPIO_ModeOut_PP_5mA); // SCLK
  GPIOA_ModeCfg(GPIO_Pin_14, GPIO_ModeOut_PP_5mA); // MOSI
  GPIOA_ModeCfg(GPIO_Pin_15, GPIO_ModeIN_Floating); // MISO

  GPIOB_ModeCfg(GPIO_Pin_8, GPIO_ModeOut_PP_5mA); // SSD1306: RST
  GPIOB_ModeCfg(GPIO_Pin_9, GPIO_ModeOut_PP_5mA); // SSD1306: DC, 0: Command, 1: Data

  SPI0_MasterDefInit();

  GPIOB_ResetBits(GPIO_Pin_8);
  delayInJiffy(60);
  GPIOB_SetBits(GPIO_Pin_8);

  GPIOB_ResetBits(GPIO_Pin_9);

  SPI0_MasterTrans((uint8_t []){ 0xAE }, 1);  // turn off
  SPI0_MasterTrans((uint8_t []){ 0x81, 0x80 }, 2);  // contrast
  SPI0_MasterTrans((uint8_t []){ 0xA8, 63 }, 2);  // Multiplex ratio, height - 1
  SPI0_MasterTrans((uint8_t []){ 0xD3, 0x00 }, 2); // set display offset
  SPI0_MasterTrans((uint8_t []){ 0xD5, 0x80 }, 2); // set osc division

  SPI0_MasterTrans((uint8_t []){ 0xD9, 0x1f }, 2); // set pre-charge period

  SPI0_MasterTrans((uint8_t []){ 0xDB, 0x40 }, 2); // set vcomh
  SPI0_MasterTrans((uint8_t []){ 0x8D, 0x14 }, 2); // set charge pump enable

  SPI0_MasterTrans((uint8_t []){ 0xA6 }, 1); // Display: A6: normal, A7: inverse

  SPI0_MasterTrans((uint8_t []){ 0x20, 0x01 }, 2);  // Memeory Address Mode

  SPI0_MasterTrans((uint8_t []){ 0xDA, 0x12 }, 2); // set COM pins
  SPI0_MasterTrans((uint8_t []){ 0xC8 }, 1); // COM Direction: C0: low to high, C8: high to low
  SPI0_MasterTrans((uint8_t []){ 0xA1 }, 1); // Segment mapping: A0: low to high, A1: high to low

  SPI0_MasterTrans((uint8_t []){ 0x2e }, 1); // turn off scroll

  SPI0_MasterTrans((uint8_t []){ 0x40 }, 1); // display start line at 0
  SPI0_MasterTrans((uint8_t []){ 0xb0 }, 1); // page start at 0

  SPI0_MasterTrans((uint8_t []){ 0xAF }, 1); // turn on

  memset(screen, 0, 1024);
  GPIOB_SetBits(GPIO_Pin_9);
  SPI0_MasterDMATrans(screen, 1024);
}

void handleATSHOW(uint8_t * payload, uint8_t len) {
  payload[len] = 0;
  putString(payload, 0, 0);
  SPI0_MasterDMATrans(screen, 1024);

  sendOK();
}

const static CommandHandler atHandlers[] = {
  { "AT", TRUE, handleAT },
  { "AT+MAC", TRUE, handleATMAC },
  { "AT+ID", TRUE, handleATID },
  { "AT+RESET", TRUE, handleATRESET },
  { "AT+ECHO=", FALSE, handleATECHO },
  { "AT+SC", TRUE, handleATSC },
  { "AT+TR=", FALSE, handleATTR },
  { "AT+SHOW=", FALSE, handleATSHOW },
  { NULL, TRUE, NULL}  // End marker
};

void taskAtCommands() {
  static uint8_t command[256];
  static uint8_t l = 0;
  static uint8_t content[128];
  BOOL LFrecevied = FALSE;

  while (ringbufferAvailable(&rxBuffer)) {
    uint8_t temp = ringbufferGet(&rxBuffer);
    if (temp == '\n') {
      LFrecevied = TRUE;
      break;
    } else {
      command[l++] = temp;
    }
  }

  if (LFrecevied) {
    BOOL handled = FALSE;
    if (command[l - 1] == '\r') {
      command[l - 1] = 0;

      for (uint8_t i = 0; atHandlers[i].command != NULL; i++) {
        if (atHandlers[i].isEqual && strcmp(command, atHandlers[i].command) == 0) {
          atHandlers[i].handler(NULL, 0);
          handled = TRUE;
          break;
        }

        if (!atHandlers[i].isEqual && startsWith(command, atHandlers[i].command)) {
          uint8_t len = genPayload(command + strlen(atHandlers[i].command), content);
          atHandlers[i].handler(content, len);
          handled = TRUE;
          break;
        }
      }
    }

    if (!handled) {
      sendError();
    }

    l = 0;
    flushUart1Tx();
  }
}

void dispatchTasks(void) {
  while (1) {
    BOOL idle = TRUE;
    for (uint8_t i = 0; i < TASK_LEN; i++) {
      if (taskList[i].ready) {
        taskList[i].ready = FALSE;
        idle = FALSE;
        taskList[i].task();
      }
    }
    if (idle) {
      __WFI();
      __nop();
      __nop();
    }
  }
}

void taskBlink(void) {
  GPIOB_InverseBits(LED);
}

static uint16_t angle = 0;

void taskReadAngle(void) {
  const uint8_t slaveAddress = 0x06;

  I2C_GenerateSTART(ENABLE);
  while (!I2C_CheckEvent(I2C_EVENT_MASTER_MODE_SELECT)); // 0x00030001

  I2C_Send7bitAddress(slaveAddress << 1, I2C_Direction_Transmitter);
  while (!I2C_CheckEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));  // 0x00070082

  I2C_SendData(0x03);
  while (!I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED));  // 0x00070084

  I2C_GenerateSTART(ENABLE);  // restart
  while (!I2C_CheckEvent(I2C_EVENT_MASTER_MODE_SELECT)); // 0x00030001

  I2C_Send7bitAddress(slaveAddress << 1, I2C_Direction_Receiver);
  while (!I2C_CheckEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)); // 0x00030002

  angle = 0;
  uint8_t readCount = 2;

  while (readCount--) {
    I2C_AcknowledgeConfig(readCount);
    while (!I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_RECEIVED)); // 0x00030040
    angle <<= 8;
    angle += I2C_ReceiveData();
  }

  I2C_GenerateSTOP(ENABLE);
  while (I2C_GetFlagStatus(I2C_FLAG_BUSY) != RESET); // 0x00000000

  angle >>= 2;
  // printf("%d\r\n", angle);
}

void taskDisplay(void) {
  static char line0[16];
  static char line3[16];
  sprintf(line0, "%8d", angle);
  uint16_t f = angle * 10000 / 4551;
  sprintf(line3, "%5d.%02d", f / 100, f % 100);
  // printf(line0);
  // printf("%d\r\n", angle);
  putString(line0, 0, 64);
  putString(line3, 6, 64);
  SPI0_MasterDMATrans(screen, 1024);
}

int main() {
  SetSysClock(CLK_SOURCE_PLL_60MHz);
  SysTick_Config(GetSysClock() / 1800); // 60Hz

  ringbufferInit(&txBuffer, 64);
  ringbufferInit(&rxBuffer, 128);

  GPIOB_ModeCfg(LED, GPIO_ModeOut_PP_5mA);
  GPIOB_SetBits(LED);

  GPIOB_ModeCfg(GPIO_Pin_12, GPIO_ModeIN_PU); // i2c SDA
  GPIOB_ModeCfg(GPIO_Pin_13, GPIO_ModeIN_PU); // i2c SCL

  I2C_Init(I2C_Mode_I2C, 400000, I2C_DutyCycle_16_9, I2C_Ack_Enable, I2C_AckAddr_7bit, 0x00);

  GPIOA_SetBits(GPIO_Pin_9);
  GPIOA_ModeCfg(GPIO_Pin_8, GPIO_ModeIN_PU);      // RXD: PA8, in with pullup
  GPIOA_ModeCfg(GPIO_Pin_9, GPIO_ModeOut_PP_5mA); // TXD: PA9, pushpull, but set it high beforehand
  UART1_DefInit();  // default baudrate 115200
  UART1_ByteTrigCfg(UART_7BYTE_TRIG);
  UART1_INTCfg(ENABLE, RB_IER_THR_EMPTY | RB_IER_RECV_RDY);
  PFIC_EnableIRQ(UART1_IRQn);

  ssdInit();

  registerTask(0, taskBlink, 180, 0);
  registerTask(1, taskAtCommands, 12, 1);
  registerTask(2, taskReadAngle, 15, 2);
  registerTask(3, taskDisplay, 30, 30);

  dispatchTasks();
}

__INTERRUPT
__HIGH_CODE
void SysTick_Handler(void) {
  jiffies++;
  SysTick->SR = 0;

  static volatile uint8_t i;
  for (i = 0; i < TASK_LEN; i++) {
    if (taskList[i].delay == 0) {
      taskList[i].ready = TRUE;
      taskList[i].delay = taskList[i].period - 1;
    } else {
      taskList[i].delay--;
    }
  }
}

__INTERRUPT
__HIGH_CODE
void UART1_IRQHandler(void) {
  switch (UART1_GetITFlag()) {
    case UART_II_THR_EMPTY: // trigger when THR and FIFOtx all empty
      while (ringbufferAvailable(&txBuffer) && R8_UART1_TFC != UART_FIFO_SIZE) {
        R8_UART1_THR = ringbufferGet(&txBuffer);
      }
      break;
    case UART_II_RECV_RDY: // Rx FIFO is full
    case UART_II_RECV_TOUT: // Rx FIFO is not full, but there is something when no new data comming in within timeout
      while (R8_UART1_RFC) {
        ringbufferPut(&rxBuffer, R8_UART1_RBR, FALSE);
      }
      break;
  }
}
